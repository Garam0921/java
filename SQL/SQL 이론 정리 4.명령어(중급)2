● SQL 명령어(중급)

4월 12일 (금)

<상식>
Apple 개발환경
- Objective C
- Swift

React Native - 모바일용 앱 만드는 기술(안드로이드, IOS 통합)
React - 웹페이지 만드는 기술

Flutter(플러터) - 구글 개발 => 언어 - Dart(다트)
 
==============================

<sql 수업>

join : 테이블을 직접적으로 합치는 것
SubQuery : 새로운 테이블을 만들어 내는 것

join 4가지
1. cross join(잘안씀)
2. inner join(중요) - 교집합을 선정하는 작업
3. outer join - 교집합을 뽑아내긴하지만, 교집합을 포함하고 있는 A 또는 B 테이블을 표현.(A테이블을 선택할지 B테이블을 선택할지 중요하며 순서도 중요)
4. self join - 자기가 자기 테이블을 또한번 조인



SubQuery : sql문 내부에서 사용하는 select문
장점, 단점
장점: 복잡한 데이터추출 및 조작작업에 유용하며 유연성과 기능확장에 도움이 됨
단점: 지나치게 복잡한 서브쿼리를 사용하면 성능을 저하시킬 수 있음 
1. 단일행 서브쿼리
2. 복수(멀티)행 서브쿼리 - in, any, all, exists


 where절에서 사용할때
서브쿼리를 먼저 만들고 그다음에 바깥에 있는 쿼리를 만들고 실행

고객, 마일리지등급, 부서, 사원, 제품, 주문, 주문세부


정규화까지 범위 - 설명문제 나올 가능성 높음.

월요일 시험문제
수업시간연습문제4개 중에서 
+ 예제문제
설명문제 2개 정도
10번 문제는 풀 쿼리 채우기 문제
나머지는 빈칸채우기

Corelated SubQuery(상관서브쿼리)

셀렉트 의 다양한 방법
방법이 여러가지
쿼리의 결과가 올바른지 확신하기 쉽지 않지음

연습문제 갯수 총 4개
중간중간 예제 문제들


 
4월 12일 (금)

sql 이론 및 예제 실습

select * from 사원;

-- 서브쿼리는 where절 뿐만 아니라 select, from, having 에도 사용 가능

-- having에 사용하는 예제
-- 고객 전체의 평균마일리지보다 평균마일리지가 큰 도시

select 도시, avg(마일리지) as 평균마일리지 from 고객
group by 도시
having avg(마일리지) > (select avg(마일리지) from 고객);


-- from에 사용하는 예제 ('인라인뷰'라고 부름)
-- 담당자명, 고객회사명, 마일리지, 도시, 해당 도시의 평균마일리지
-- 도시의 평균마일리지와 각 고객의 마일리지의 차(-)도 함께 표현

select 담당자명, 고객회사명, 마일리지, 고객.도시, 도시평균마일리지, (도시평균마일리지 - 마일리지) as 차이 
from 고객, (select 도시, avg(마일리지) as 도시평균마일리지
			from 고객 group by 도시) as 도시별요약
where 고객.도시 = 도시별요약.도시;			

-- inner join으로 바꾼 예제
select 담당자명, 고객회사명, 마일리지, 고객.도시, 도시평균마일리지, (도시평균마일리지 - 마일리지) as 차이 
from 고객
inner join (select 도시, avg(마일리지) as 도시평균마일리지 from 고객 group by 도시) as 도시별요약
on 고객.도시 = 도시별요약.도시;
                                                                        

-- select에 사용하는 예제
-- 하나의 값만 반환하는 쿼리여야 함(Scalar Subquery)
-- 고객번호, 담당자명, 고객의 최종주문일

select 고객번호, 담당자명, (select max(주문일) from 주문 where 주문.고객번호 = 고객.고객번호) as 최종주문일
	from 고객;



-- 다중컬럼 서브쿼리 : 스브쿼리에서 여러개의 컬럼을 사용하는 경우
-- 각 도시마다 최고 마일리지를 보유한 고객의 정보

select 도시, 담당자명, 고객회사명, 마일리지 from 고객
where (도시, 마일리지) in (select 도시, max(마일리지) from 고객
group by 도시);



-- 상관 서브쿼리 (Corelated SubQuery)
/* main쿼리 와 서브쿼리간의 상관관계를 포함하는 형태의 쿼리.
상관서브쿼리는 메인쿼리와 한 행씩 실행하며 처리함.
그렇기 때문에 실행속도가 늦어질 가능성이 있음 */
-- 사원의 정보와 상사의 정보를 함께 표현

select 사원번호, 이름, 상사번호, 
	(select 이름 from 사원 as 상사
		where 상사.사원번호 = 사원.상사번호) as 상사이름 from 사원;

-- 특정 주문일 범위안에서 각 주문번호당 총 판매금액
select 주문번호, 주문일,
	(select sum(주문세부.주문수량 * 주문세부.단가) from 주문세부
		where 주문세부.주문번호 = 주문.주문번호) as 총판매금액 from 주문
where 주문일 between '2022-01-01' and '2022-12-31';		

-- 위의 상관쿼리를 비상관코리로 변경하면,
select 주문.주문번호, 주문일,
	sum(주문세부.주문수량 * 주문세부.단가) as 총판매금액 from 주문
left join 주문세부
on 주문세부.주문번호 = 주문.주문번호 
where 주문일 between '2022-01-01' and '2022-12-31'
group by 주문.주문번호, 주문.주문일;

-- '배재용'사원의 부서명
-- 비상관쿼리
select 부서명 from 부서
where 부서번호 = (select 부서번호 from 사원
			   where 이름 = '배재용');
			  
-- 상관쿼리
select (select  부서명 from 부서 
		where 부서.부서번호 = 사원.부서번호) as 부서명
from 사원
where 이름 = '배재용';


-- 담당자명, 고객회사명, 주문건수(count), 최초주문일(min), 최종주문일(max)
-- 서브쿼리 이용해서 표현하시요

select 담당자명, 고객회사명, 주문건수, 최초주문일, 최종주문일 from 고객
inner join (select 고객번호, count(*) as 주문건수,
						  min(주문일) as  최초주문일,
						  max(주문일) as 최종주문일 from 주문
						  group by 고객번호) as 주문요약
on 주문요약.고객번호 = 고객.고객번호 ;	